---
title: 前端判断数据类型
date: 2021-08-16 22:44:05
description: JavaScript数据类型的一些总结
keywords: 'js类型判断'
tags: 
  - Javascript
# 配置置顶
# sticky: 1 
cover: 'https://images.unsplash.com/photo-1580983703451-bf6bb44a9917?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=750&q=80'
top_img: https://th.wallhaven.cc/small/6o/6olw9x.jpg
---

目前前端的数据类型有 _8_ 种，其中 _7_  种 为**基础类型**和一种特殊的 **引用类型**

- 基础类型：Number、String、Null、undefined、Boolean、Symbol、BigInt

- 引用类型：Objetc

**值得注意的是其中 BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数，一般我们用在数字后面加n或者是函数bigInt()来调用；**

那么我们在一下具体的逻辑业务中需要判断一些数据的类型，所以我总结了一些比较常用的判断数据方法如下：

1. **typeof**
    使用方法列如 ``typeof 12 == "number" ``

    除了下面几种特殊情况都可以正常返回
    - `typeof null`  返回类型错误，返回object
    - 引用类型，除了function返回function类型外，其他均返回object。

    其中，`null` 有属于自己的数据类型 `Null` ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 `typeof` 对于这些类型的处理，只返回了处于其原型链最顶端的 `Object` 类型，没有错，但不是我们想要的结果。

2. **toString 这个是最完美的**

    toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 `[[Class]]` 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型

    具体的使用方法为
    ```js
    Object.prototype.toString.call('') ;   // [object String]

    Object.prototype.toString.call(1) ;    // [object Number]

    Object.prototype.toString.call(true) ; // [object Boolean]

    Object.prototype.toString.call(Symbol()); //[object Symbol]

    Object.prototype.toString.call(undefined) ; // [object Undefined]

    Object.prototype.toString.call(null) ; // [object Null]

    Object.prototype.toString.call(new Function()) ; // [object Function]

    Object.prototype.toString.call(new Date()) ; // [object Date]

    Object.prototype.toString.call([]) ; // [object Array]

    Object.prototype.toString.call(new RegExp()) ; // [object RegExp]

    Object.prototype.toString.call(new Error()) ; // [object Error]

    Object.prototype.toString.call(document) ; // [object HTMLDocument]
    
    Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用
    ```

3. **constructor(构造函数)**

    `constructor`是原型`prototype`的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个`prototype`中`constructor`属性指向函数引用， 因此重写`prototype`会丢失原来的`constructor`。

    ```js
    '123'.constructor=='String'
    ```

    但是有一个问题就是`null`和`undefined`没有构造函数

4. **instanceof**

    该方法为是用来判断 A 是否为 B 的实例，表达式为：``A instanceof B``，如果 A 是 B 的实例，则返回 `true`,否则返回 `false`。 在这里需要特别注意的是：`instanceof` 检测的是原型

    ```js
    {} instanceof Object; //true

    [] instanceof Array;  //true

    [] instanceof Object; //true

    "123" instanceof String; //false

    new String(123) instanceof String; //true
    ```
5. **Array.isArray**

   因数组类型常常被使用，故在数组的api中提供了这个单独对数组的判断方法
   改方法只针对数组的判断，非数组类型直接返回`null`
   ```js
   alert(Array.isArray({})); // false
   alert(Array.isArray([])); // true
    ```
   