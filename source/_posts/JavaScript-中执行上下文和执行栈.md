---
title: JavaScript 中执行上下文和执行栈
date: 2023-05-15 10:54:25
cover: https://www.foodiesfeed.com/wp-content/uploads/2023/05/spices-on-wooden-spoons.jpg
tags:
 - JavaScript
categories: 
  - 前端学习
---


# 理解执行上下文

 **执行上下文**是当前`JavaScript`代码`被解析`和`执行时所在环境`的**抽象概念**

## 执行上下文的类型

执行上下文总共有三种类型

- **全局执行上下文**：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。
- **函数执行上下文**：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
- **Eval 函数执行上下文**： 指的是运行在 eval 函数中的代码，很少用而且不建议使用

## 执行栈

执行栈，也叫调用栈，具有`LIFO（后进先出）`结构，用于存储在代码执行期间创建的所有执行上下文。
首次运行JS代码时，会创建一个**全局执行上下文**并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。
根据执行栈`LIFO`规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。

## 执行上下文的创建

执行上下文的创建分两个阶段:**创建阶段**、**执行阶段**

**创建阶段**

1. 确定 this 的值，也被称为 `This Binding`。
   - **全局**执行上下文中，this 的值指向全局对象，在浏览器中this 的值指向 window对象，而在nodejs中指向这个文件的module对象。
   - **函数**执行上下文中，this 的值取决于函数的调用方式。具体有：`默认绑定`、`隐式绑定`、`显式绑定（硬绑定）`、`new绑定`、`箭头函数`

2. `LexicalEnvironment（词法环境）` 组件被创建。
    - **环境记录**：存储变量和函数声明的实际位置
    - **对外部环境的引用**：可以访问其外部词法环境,全局环境外部环境引用为`null`

3. `VariableEnvironment（变量环境）` 组件被创建。
   变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。
   在 ES6 中，**词法环境**和**变量环境**的区别在于前者用于存储**函数声明和变量** `let` **和** `const` **绑定，而后者仅用于存储变量**`var`绑定。

    ```js
        //伪代码
        ExecutionContext = {  
            ThisBinding = <this value>,     // 确定this 
            LexicalEnvironment = { ... },   // 词法环境
            VariableEnvironment = { ... },  // 变量环境
        }
    ```

>加餐:变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 `undefined`（在 `var` 的情况下）或保持未初始化（在 `let` 和 `const` 的情况下）。所以这就是为什么可以在声明之前访问 `var` 定义的变量（尽管是 `undefined` ），但如果在声明之前访问 `let` 和 `const` 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。**函数提升>变量提升**

**执行阶段**

此阶段，完成对所有变量的分配，最后执行代码。
如果 `Javascript` 引擎在源代码中声明的实际位置找不到 `let` 变量的值，那么将为其分配 `undefined` 值

# 深入之执行上下文栈和变量对象

JS是单线程的语言，执行顺序肯定是顺序执行，但是JS 引擎**并不是**一行一行地分析和执行程序，**而是**一段一段地分析执行，会先进行编译阶段然后才是执行阶段。

## 执行上下文栈

因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。
当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个全局执行上下文。

## 函数上下文

在函数上下文中，用活动对象(activation object, AO)来表示变量对象

1. **变量对象（VO）**是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。
2. 当进入到一个执行上下文后，这个变量对象才会被激活，所以叫**活动对象（AO）**，这时候活动对象上的各种属性才能被访问。

执行上下文的代码会分成两个阶段进行处理:1.**进入执行上下文**;2.**代码执行**

进入执行上下文:很明显，这个时候还没有执行代码,此时的**变量对象**会包括（如下顺序初始化）

- 函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。
- 函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。
- 变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。

**总结**:

1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值


>借鉴[文章](https://muyiy.cn/blog/1/1.1.html#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%B1%BB%E5%9E%8B)